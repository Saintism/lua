--// Variables
local players = game:GetService('Players')
local runservice = game:GetService('RunService')

local localplayer = players.LocalPlayer
local current_camera = workspace.CurrentCamera
local character_size = Vector3.new(4, 5.75, 1.5)
local character_offset = CFrame.new(0, -0.25, 0)

local esp = {
    box = true,
    box_color = Color3.new(1, 1, 1),

    healthbar = true,
    healthbar_color1 = Color3.new(0, 1, 0),
    healthbar_color2 = Color3.new(1, 0, 0),

    ignore_localplayer = true,
    
    chams = true,
    chams_inline_color = Color3.new(0, 0, 0),
    chams_inline_transparency = 0.89,
    chams_outline_color = Color3.new(1, 0, 0),
    chams_outline_transparency = 0
}

function vector2_floor(vector2)
    return Vector2.new(math.floor(vector2.X), math.floor(vector2.Y))
end

function cframe_to_viewport(cframe, floor)
    local position, visible = current_camera.WorldToViewportPoint(current_camera, cframe * (cframe - cframe.p):ToObjectSpace(current_camera.CFrame - current_camera.CFrame.p).p)
    if floor then
        position = vector2_floor(position)
    end
    return position, visible
end

local players_tbl = {}
local player = {}
player.__index = player

function player.new(instance)
    local player_data = {}

    player_data.highlight = Instance.new('Highlight')
    player_data.instance = instance
    player_data.drawings = {
        box = Drawing.new('Square', {Thickness = 1, ZIndex = 2}),
        box_outline = Drawing.new('Square', {Thickness = 3}),
        healthbar = Drawing.new('Square', {ZIndex = 2, Thickness = 1, Filled = true}),
        healthbar_outline = Drawing.new('Square', {ZIndex = 1, Thickness = 3, Filled = true}),
    }

    table.insert(players_tbl, player_data)

    return setmetatable(player_data, player)
end

function player:Check()
    local player = self.instance
    local humanoid = player.Character and player.Character:FindFirstChildWhichIsA('Humanoid')
    local rootpart = player.Character and player.Character:FindFirstChild('HumanoidRootPart')

    if not rootpart or not humanoid then
        return false
    end

    if humanoid.Health <= 0 then
        return false
    end

    local screen_position, screen_visible = cframe_to_viewport(rootpart.CFrame * character_offset, true)

    if not screen_visible then
        return false
    end

    return true, {
        HumanoidRootPart = rootpart,
        Humanoid = humanoid,
        ScreenPosition = screen_position,
        Character = player.Character
    }
end

function player:Step()
    local drawings = self.drawings
    local check_pass, check_data = self:Check()
    
    if not check_pass then 
        self:SetVisibility(false) 
        return
    end

    local box_size = self:CalculateBoxSize(check_data.ScreenPosition, check_data.HumanoidRootPart.CFrame * character_offset)
    local box_position = vector2_floor(check_data.ScreenPosition - (box_size / 2))
    local health_factor = check_data.Humanoid.Health / check_data.Humanoid.MaxHealth

    drawings.box.Visible = esp.box
    drawings.box.Position = box_position
    drawings.box.Size = box_size
    drawings.box.Color = esp.box_color

    drawings.box_outline.Visible = esp.box
    drawings.box_outline.Position = box_position
    drawings.box_outline.Size = box_size

    drawings.healthbar_outline.Visible = esp.healthbar
    drawings.healthbar_outline.Size = Vector2.new(3, box_size.Y + 2)
    drawings.healthbar_outline.Position = Vector2.new(box_position.X - 6, box_position.Y - 1)

    drawings.healthbar.Visible = esp.healthbar
    drawings.healthbar.Size = Vector2.new(1, health_factor * box_size.Y)
    drawings.healthbar.Position = drawings.healthbar_outline.Position + Vector2.new(1, (box_size.Y + 3) - drawings.healthbar_outline.Size.Y)
    drawings.healthbar.Color = esp.healthbar_color1:lerp(esp.healthbar_color2, 1 - health_factor)

    self.highlight.Enabled = esp.chams
    self.highlight.FillColor = esp.chams_inline_color
    self.highlight.FillTransparency = esp.chams_inline_transparency
    self.highlight.OutlineColor = esp.chams_outline_color
    self.highlight.OutlineTransparency = esp.chams_outline_transparency
    self.highlight.Adornee = check_data.Character 
    self.highlight.Parent = check_data.Character
end


function player:SetVisibility(bool)
    for i, v in next, self.drawings do
        v.Visible = bool
    end
end

function player:CalculateBoxSize(ScreenPosition, cframe)
    local x = cframe_to_viewport(cframe * CFrame.new(character_size.X, 0, 0), true)
    local y = cframe_to_viewport(cframe * CFrame.new(0, character_size.Y, 0), true)
    local z = cframe_to_viewport(cframe * CFrame.new(0, 0, character_size.Z), true)

    local SizeX = math.max(math.abs(ScreenPosition.X - x.X), math.abs(ScreenPosition.X - z.X))
    local SizeY = math.max(math.abs(ScreenPosition.Y - y.Y), math.abs(ScreenPosition.Y - x.Y))
    return Vector2.new(math.clamp(math.floor(SizeX),3,9999), math.clamp(math.floor(SizeY),6, 9999))
end

function player:GetBoxColor()
    return self.drawings.box.Color
end

function player:SetBoxColor(color)
    self.drawings.box.Color = color
end

local old; old = hookfunction(Drawing.new, function(class, properties)
    local drawing = old(class)

    for i, v in next, properties or {} do
        drawing[i] = v
    end

    return drawing
end)

-- local bleh = player.new(localplayer)

-- while task.wait(1/120) do
--     bleh:Step()
-- end

esp.player = player
return esp
